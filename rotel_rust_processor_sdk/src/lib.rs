// SPDX-License-Identifier: Apache-2.0

//! Rotel Rust Processor SDK
//!
//! This crate provides the interface for building Rust-based processors for Rotel.
//! Processors are compiled as dynamic libraries (.so/.dylib/.dll) and loaded at runtime.
//!
//! # Quick Start
//!
//! 1. Create a new library crate with `crate-type = ["cdylib"]`
//! 2. Implement the `RotelProcessor` trait
//! 3. Use the `export_processor!` macro to export your processor
//!
//! # Example
//!
//! ```ignore
//! use rotel_rust_processor_sdk::prelude::*;
//!
//! pub struct MyProcessor;
//!
//! impl RotelProcessor for MyProcessor {
//!     fn process_spans(
//!         &self,
//!         mut spans: RResourceSpans,
//!         _context: ROption<RRequestContext>,
//!     ) -> RResourceSpans {
//!         // Add an attribute to every span
//!         for scope_spans in spans.scope_spans.iter_mut() {
//!             for span in scope_spans.spans.iter_mut() {
//!                 span.attributes.push(RKeyValue::string("processed", "true"));
//!             }
//!         }
//!         spans
//!     }
//! }
//!
//! export_processor!(MyProcessor);
//! ```

pub mod convert;
pub mod processor;
pub mod types;

// Re-export abi_stable types that plugins need
pub use abi_stable;
pub use abi_stable::std_types::{RBox, ROption, RStr, RString, RVec};
pub use abi_stable::StableAbi;

// Re-export tokio for use by the export_async_processor! macro.
// Not public API â€” users don't need to depend on tokio directly.
#[doc(hidden)]
pub use tokio as __tokio;

// Re-export the processor trait and its generated types
pub use processor::{
    AsyncProcessor, AsyncRotelProcessor, AsyncRotelProcessor_TO, ProcessorInfo, RotelProcessor,
    RotelProcessor_TO,
};

/// Helper function to extract a panic message from a caught panic.
/// Used internally by the `export_processor!` macro. Not public API.
#[doc(hidden)]
pub fn __extract_panic_message(err: &Box<dyn std::any::Any + Send>) -> String {
    if let Some(s) = err.downcast_ref::<&str>() {
        s.to_string()
    } else if let Some(s) = err.downcast_ref::<String>() {
        s.clone()
    } else {
        "unknown panic".to_string()
    }
}

// The convert module is internal but can be used by host implementations

/// Prelude module for convenient imports
pub mod prelude {
    pub use crate::processor::{
        AsyncProcessor, AsyncRotelProcessor, ProcessorInfo, RotelProcessor,
    };
    pub use crate::types::*;
    pub use crate::{export_async_processor, export_processor, ROption, RString, RVec};
}

use abi_stable::{library::RootModule, package_version_strings, sabi_types::VersionStrings};

/// The root module that plugins must export.
///
/// This is automatically generated by the `export_processor!` macro.
#[repr(C)]
#[derive(StableAbi)]
#[sabi(kind(Prefix(prefix_ref = ProcessorModuleRef)))]
pub struct ProcessorModule {
    /// Creates a new instance of the processor
    #[sabi(last_prefix_field)]
    pub new_processor: extern "C" fn() -> RotelProcessor_TO<'static, RBox<()>>,
}

impl RootModule for ProcessorModuleRef {
    abi_stable::declare_root_module_statics! {ProcessorModuleRef}

    const BASE_NAME: &'static str = "rotel_processor";
    const NAME: &'static str = "rotel_processor";
    const VERSION_STRINGS: VersionStrings = package_version_strings!();
}

/// The root module for async processors.
///
/// This is a separate module from `ProcessorModule` to preserve ABI backward compatibility.
/// Automatically generated by the `export_async_processor!` macro.
#[repr(C)]
#[derive(StableAbi)]
#[sabi(kind(Prefix(prefix_ref = AsyncProcessorModuleRef)))]
pub struct AsyncProcessorModule {
    /// Creates a new instance of the async processor
    #[sabi(last_prefix_field)]
    pub new_processor: extern "C" fn() -> AsyncRotelProcessor_TO<'static, RBox<()>>,
}

impl RootModule for AsyncProcessorModuleRef {
    abi_stable::declare_root_module_statics! {AsyncProcessorModuleRef}

    const BASE_NAME: &'static str = "rotel_async_processor";
    const NAME: &'static str = "rotel_async_processor";
    const VERSION_STRINGS: VersionStrings = package_version_strings!();
}

/// Macro to export a processor implementation.
///
/// This macro generates the necessary FFI glue code to make your processor
/// loadable by Rotel at runtime.
///
/// # Usage
///
/// ```ignore
/// use rotel_rust_processor_sdk::prelude::*;
///
/// pub struct MyProcessor;
///
/// impl RotelProcessor for MyProcessor {
///     // ... implement methods
/// }
///
/// // Export the processor - this must be called exactly once per library
/// export_processor!(MyProcessor);
/// ```
///
/// # Requirements
///
/// - Your processor type must implement `RotelProcessor`
/// - Your processor type must implement `Default` or have a `new()` constructor
/// - The macro should be called at the crate root level
#[macro_export]
macro_rules! export_processor {
    ($processor_type:ty) => {
        /// Panic-safe wrapper generated by `export_processor!`.
        ///
        /// Catches panics inside the dylib before they can cross the FFI boundary,
        /// which would otherwise be undefined behavior. If a panic occurs, the
        /// telemetry data passes through in whatever state it was in at the time
        /// of the panic (potentially partially modified).
        struct __RotelPanicSafeWrapper {
            inner: $processor_type,
        }

        impl Default for __RotelPanicSafeWrapper {
            fn default() -> Self {
                Self {
                    inner: <$processor_type>::default(),
                }
            }
        }

        impl $crate::processor::RotelProcessor for __RotelPanicSafeWrapper {
            fn process_spans(
                &self,
                spans: &mut $crate::types::RResourceSpans,
                context: &$crate::ROption<$crate::types::RRequestContext>,
            ) {
                let result = ::std::panic::catch_unwind(::std::panic::AssertUnwindSafe(|| {
                    self.inner.process_spans(spans, context);
                }));
                if let Err(e) = result {
                    let msg = $crate::__extract_panic_message(&e);
                    eprintln!(
                        "[rotel-processor] PANIC in {}.process_spans: {} - data may be incomplete",
                        stringify!($processor_type),
                        msg,
                    );
                }
            }

            fn process_logs(
                &self,
                logs: &mut $crate::types::RResourceLogs,
                context: &$crate::ROption<$crate::types::RRequestContext>,
            ) {
                let result = ::std::panic::catch_unwind(::std::panic::AssertUnwindSafe(|| {
                    self.inner.process_logs(logs, context);
                }));
                if let Err(e) = result {
                    let msg = $crate::__extract_panic_message(&e);
                    eprintln!(
                        "[rotel-processor] PANIC in {}.process_logs: {} - data may be incomplete",
                        stringify!($processor_type),
                        msg,
                    );
                }
            }

            fn process_metrics(
                &self,
                metrics: &mut $crate::types::RResourceMetrics,
                context: &$crate::ROption<$crate::types::RRequestContext>,
            ) {
                let result = ::std::panic::catch_unwind(::std::panic::AssertUnwindSafe(|| {
                    self.inner.process_metrics(metrics, context);
                }));
                if let Err(e) = result {
                    let msg = $crate::__extract_panic_message(&e);
                    eprintln!(
                        "[rotel-processor] PANIC in {}.process_metrics: {} - data may be incomplete",
                        stringify!($processor_type),
                        msg,
                    );
                }
            }
        }

        /// FFI entry point for the processor library
        #[abi_stable::export_root_module]
        pub fn get_library() -> $crate::ProcessorModuleRef {
            use $crate::abi_stable::prefix_type::PrefixTypeTrait;

            $crate::ProcessorModule {
                new_processor: {
                    extern "C" fn create_processor(
                    ) -> $crate::RotelProcessor_TO<'static, $crate::RBox<()>> {
                        let processor = __RotelPanicSafeWrapper::default();
                        $crate::RotelProcessor_TO::from_value(
                            processor,
                            $crate::abi_stable::sabi_trait::TD_Opaque,
                        )
                    }
                    create_processor
                },
            }
            .leak_into_prefix()
        }
    };
}

/// Macro to export an async processor implementation.
///
/// This macro generates the necessary FFI glue code to make your async processor
/// loadable by Rotel at runtime. It creates a tokio runtime automatically and
/// bridges your `async fn` methods to the FFI boundary.
///
/// # Usage
///
/// ```ignore
/// use rotel_rust_processor_sdk::prelude::*;
///
/// #[derive(Default)]
/// pub struct MyProcessor;
///
/// impl AsyncProcessor for MyProcessor {
///     async fn process_spans(
///         &self,
///         mut spans: RResourceSpans,
///         _context: ROption<RRequestContext>,
///     ) -> RResourceSpans {
///         let data = fetch_enrichment().await;
///         // ... modify spans ...
///         spans
///     }
/// }
///
/// export_async_processor!(MyProcessor);
/// ```
///
/// # Requirements
///
/// - Your processor type must implement `AsyncProcessor`
/// - Your processor type must implement `Default`
/// - The macro should be called at the crate root level
#[macro_export]
macro_rules! export_async_processor {
    ($processor_type:ty) => {
        /// Runtime-managing, panic-safe wrapper generated by `export_async_processor!`.
        ///
        /// Owns a tokio runtime that is created in `start()` and used to run the
        /// user's `async fn` methods via `block_on()`. Also catches panics inside
        /// the dylib before they can cross the FFI boundary.
        struct __RotelAsyncPanicSafeWrapper {
            inner: $processor_type,
            runtime: ::std::sync::OnceLock<$crate::__tokio::runtime::Runtime>,
        }

        impl Default for __RotelAsyncPanicSafeWrapper {
            fn default() -> Self {
                Self {
                    inner: <$processor_type>::default(),
                    runtime: ::std::sync::OnceLock::new(),
                }
            }
        }

        impl $crate::processor::AsyncRotelProcessor for __RotelAsyncPanicSafeWrapper {
            fn start(&self) {
                let result = ::std::panic::catch_unwind(::std::panic::AssertUnwindSafe(|| {
                    let rt = $crate::__tokio::runtime::Builder::new_current_thread()
                        .enable_all()
                        .build()
                        .expect("Failed to create tokio runtime for async processor");
                    self.runtime
                        .set(rt)
                        .expect("start() called more than once");
                    self.inner.start();
                }));
                if let Err(e) = result {
                    let msg = $crate::__extract_panic_message(&e);
                    eprintln!(
                        "[rotel-async-processor] PANIC in {}.start: {}",
                        stringify!($processor_type),
                        msg,
                    );
                }
            }

            fn shutdown(&self) {
                let result = ::std::panic::catch_unwind(::std::panic::AssertUnwindSafe(|| {
                    self.inner.shutdown();
                }));
                if let Err(e) = result {
                    let msg = $crate::__extract_panic_message(&e);
                    eprintln!(
                        "[rotel-async-processor] PANIC in {}.shutdown: {}",
                        stringify!($processor_type),
                        msg,
                    );
                }
            }

            fn process_spans(
                &self,
                spans: $crate::types::RResourceSpans,
                context: $crate::ROption<$crate::types::RRequestContext>,
            ) -> $crate::types::RResourceSpans {
                let rt = self.runtime.get()
                    .expect("start() was not called before process_spans()");
                let backup = spans.clone();
                let result = ::std::panic::catch_unwind(::std::panic::AssertUnwindSafe(|| {
                    rt.block_on(self.inner.process_spans(spans, context))
                }));
                match result {
                    Ok(spans) => spans,
                    Err(e) => {
                        let msg = $crate::__extract_panic_message(&e);
                        eprintln!(
                            "[rotel-async-processor] PANIC in {}.process_spans: {} - data passed through unmodified",
                            stringify!($processor_type),
                            msg,
                        );
                        backup
                    }
                }
            }

            fn process_logs(
                &self,
                logs: $crate::types::RResourceLogs,
                context: $crate::ROption<$crate::types::RRequestContext>,
            ) -> $crate::types::RResourceLogs {
                let rt = self.runtime.get()
                    .expect("start() was not called before process_logs()");
                let backup = logs.clone();
                let result = ::std::panic::catch_unwind(::std::panic::AssertUnwindSafe(|| {
                    rt.block_on(self.inner.process_logs(logs, context))
                }));
                match result {
                    Ok(logs) => logs,
                    Err(e) => {
                        let msg = $crate::__extract_panic_message(&e);
                        eprintln!(
                            "[rotel-async-processor] PANIC in {}.process_logs: {} - data passed through unmodified",
                            stringify!($processor_type),
                            msg,
                        );
                        backup
                    }
                }
            }

            fn process_metrics(
                &self,
                metrics: $crate::types::RResourceMetrics,
                context: $crate::ROption<$crate::types::RRequestContext>,
            ) -> $crate::types::RResourceMetrics {
                let rt = self.runtime.get()
                    .expect("start() was not called before process_metrics()");
                let backup = metrics.clone();
                let result = ::std::panic::catch_unwind(::std::panic::AssertUnwindSafe(|| {
                    rt.block_on(self.inner.process_metrics(metrics, context))
                }));
                match result {
                    Ok(metrics) => metrics,
                    Err(e) => {
                        let msg = $crate::__extract_panic_message(&e);
                        eprintln!(
                            "[rotel-async-processor] PANIC in {}.process_metrics: {} - data passed through unmodified",
                            stringify!($processor_type),
                            msg,
                        );
                        backup
                    }
                }
            }
        }

        /// FFI entry point for the async processor library
        #[abi_stable::export_root_module]
        pub fn get_library() -> $crate::AsyncProcessorModuleRef {
            use $crate::abi_stable::prefix_type::PrefixTypeTrait;

            $crate::AsyncProcessorModule {
                new_processor: {
                    extern "C" fn create_processor(
                    ) -> $crate::AsyncRotelProcessor_TO<'static, $crate::RBox<()>> {
                        let processor = __RotelAsyncPanicSafeWrapper::default();
                        $crate::AsyncRotelProcessor_TO::from_value(
                            processor,
                            $crate::abi_stable::sabi_trait::TD_Opaque,
                        )
                    }
                    create_processor
                },
            }
            .leak_into_prefix()
        }
    };
}
