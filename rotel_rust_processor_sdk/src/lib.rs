// SPDX-License-Identifier: Apache-2.0

//! Rotel Rust Processor SDK
//!
//! This crate provides the interface for building Rust-based processors for Rotel.
//! Processors are compiled as dynamic libraries (.so/.dylib/.dll) and loaded at runtime.
//!
//! # Quick Start
//!
//! 1. Create a new library crate with `crate-type = ["cdylib"]`
//! 2. Implement the `RotelProcessor` trait
//! 3. Use the `export_processor!` macro to export your processor
//!
//! # Example
//!
//! ```ignore
//! use rotel_rust_processor_sdk::prelude::*;
//!
//! pub struct MyProcessor;
//!
//! impl RotelProcessor for MyProcessor {
//!     fn process_spans(
//!         &self,
//!         mut spans: RResourceSpans,
//!         _context: ROption<RRequestContext>,
//!     ) -> RResourceSpans {
//!         // Add an attribute to every span
//!         for scope_spans in spans.scope_spans.iter_mut() {
//!             for span in scope_spans.spans.iter_mut() {
//!                 span.attributes.push(RKeyValue::string("processed", "true"));
//!             }
//!         }
//!         spans
//!     }
//! }
//!
//! export_processor!(MyProcessor);
//! ```

pub mod convert;
pub mod processor;
pub mod types;

// Re-export abi_stable types that plugins need
pub use abi_stable;
pub use abi_stable::std_types::{RBox, ROption, RStr, RString, RVec};
pub use abi_stable::StableAbi;

// Re-export the processor trait and its generated types
pub use processor::{ProcessorInfo, RotelProcessor, RotelProcessor_TO};

/// Helper function to extract a panic message from a caught panic.
/// Used internally by the `export_processor!` macro. Not public API.
#[doc(hidden)]
pub fn __extract_panic_message(err: &Box<dyn std::any::Any + Send>) -> String {
    if let Some(s) = err.downcast_ref::<&str>() {
        s.to_string()
    } else if let Some(s) = err.downcast_ref::<String>() {
        s.clone()
    } else {
        "unknown panic".to_string()
    }
}

// The convert module is internal but can be used by host implementations

/// Prelude module for convenient imports
pub mod prelude {
    pub use crate::processor::{ProcessorInfo, RotelProcessor};
    pub use crate::types::*;
    pub use crate::{export_processor, ROption, RString, RVec};
}

use abi_stable::{library::RootModule, package_version_strings, sabi_types::VersionStrings};

/// The root module that plugins must export.
///
/// This is automatically generated by the `export_processor!` macro.
#[repr(C)]
#[derive(StableAbi)]
#[sabi(kind(Prefix(prefix_ref = ProcessorModuleRef)))]
pub struct ProcessorModule {
    /// Creates a new instance of the processor
    #[sabi(last_prefix_field)]
    pub new_processor: extern "C" fn() -> RotelProcessor_TO<'static, RBox<()>>,
}

impl RootModule for ProcessorModuleRef {
    abi_stable::declare_root_module_statics! {ProcessorModuleRef}

    const BASE_NAME: &'static str = "rotel_processor";
    const NAME: &'static str = "rotel_processor";
    const VERSION_STRINGS: VersionStrings = package_version_strings!();
}

/// Macro to export a processor implementation.
///
/// This macro generates the necessary FFI glue code to make your processor
/// loadable by Rotel at runtime.
///
/// # Usage
///
/// ```ignore
/// use rotel_rust_processor_sdk::prelude::*;
///
/// pub struct MyProcessor;
///
/// impl RotelProcessor for MyProcessor {
///     // ... implement methods
/// }
///
/// // Export the processor - this must be called exactly once per library
/// export_processor!(MyProcessor);
/// ```
///
/// # Requirements
///
/// - Your processor type must implement `RotelProcessor`
/// - Your processor type must implement `Default` or have a `new()` constructor
/// - The macro should be called at the crate root level
#[macro_export]
macro_rules! export_processor {
    ($processor_type:ty) => {
        /// Panic-safe wrapper generated by `export_processor!`.
        ///
        /// Catches panics inside the dylib before they can cross the FFI boundary,
        /// which would otherwise be undefined behavior. If a panic occurs, the
        /// telemetry data passes through in whatever state it was in at the time
        /// of the panic (potentially partially modified).
        struct __RotelPanicSafeWrapper {
            inner: $processor_type,
        }

        impl Default for __RotelPanicSafeWrapper {
            fn default() -> Self {
                Self {
                    inner: <$processor_type>::default(),
                }
            }
        }

        impl $crate::processor::RotelProcessor for __RotelPanicSafeWrapper {
            fn process_spans(
                &self,
                spans: &mut $crate::types::RResourceSpans,
                context: &$crate::ROption<$crate::types::RRequestContext>,
            ) {
                let result = ::std::panic::catch_unwind(::std::panic::AssertUnwindSafe(|| {
                    self.inner.process_spans(spans, context);
                }));
                if let Err(e) = result {
                    let msg = $crate::__extract_panic_message(&e);
                    eprintln!(
                        "[rotel-processor] PANIC in {}.process_spans: {} - data may be incomplete",
                        stringify!($processor_type),
                        msg,
                    );
                }
            }

            fn process_logs(
                &self,
                logs: &mut $crate::types::RResourceLogs,
                context: &$crate::ROption<$crate::types::RRequestContext>,
            ) {
                let result = ::std::panic::catch_unwind(::std::panic::AssertUnwindSafe(|| {
                    self.inner.process_logs(logs, context);
                }));
                if let Err(e) = result {
                    let msg = $crate::__extract_panic_message(&e);
                    eprintln!(
                        "[rotel-processor] PANIC in {}.process_logs: {} - data may be incomplete",
                        stringify!($processor_type),
                        msg,
                    );
                }
            }

            fn process_metrics(
                &self,
                metrics: &mut $crate::types::RResourceMetrics,
                context: &$crate::ROption<$crate::types::RRequestContext>,
            ) {
                let result = ::std::panic::catch_unwind(::std::panic::AssertUnwindSafe(|| {
                    self.inner.process_metrics(metrics, context);
                }));
                if let Err(e) = result {
                    let msg = $crate::__extract_panic_message(&e);
                    eprintln!(
                        "[rotel-processor] PANIC in {}.process_metrics: {} - data may be incomplete",
                        stringify!($processor_type),
                        msg,
                    );
                }
            }
        }

        /// FFI entry point for the processor library
        #[abi_stable::export_root_module]
        pub fn get_library() -> $crate::ProcessorModuleRef {
            use $crate::abi_stable::prefix_type::PrefixTypeTrait;

            $crate::ProcessorModule {
                new_processor: {
                    extern "C" fn create_processor(
                    ) -> $crate::RotelProcessor_TO<'static, $crate::RBox<()>> {
                        let processor = __RotelPanicSafeWrapper::default();
                        $crate::RotelProcessor_TO::from_value(
                            processor,
                            $crate::abi_stable::sabi_trait::TD_Opaque,
                        )
                    }
                    create_processor
                },
            }
            .leak_into_prefix()
        }
    };
}
